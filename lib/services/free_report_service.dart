// lib/services/free_report_service.dart

import 'package:flutter/foundation.dart'; // For debugPrint
import 'dart:math'; // For min/max calculations

import '../models/interview_model.dart'; // For InterviewAnalysis model

// This service aggregates individual question analyses and generates a
// comprehensive overall interview report.

class FreeReportService {
  FreeReportService();

  // Generates an overall interview report based on collected data.
  // This method takes all responses, emotion data, interview duration,
  // and individual speech analyses to create a holistic report.
  Future<InterviewAnalysis> generateReport({
    required List<String> responses,
    required List<Map<String, double>> emotionTimeline, // List of emotion maps per response
    required Duration interviewDuration,
    required List<Map<String, dynamic>> individualSpeechAnalyses, // List of speech analysis maps
  }) async {
    debugPrint('Generating overall interview report...');

    // --- Aggregate Speech Metrics ---
    double totalSpeakingRateWPM = 0.0;
    int totalFillerWordCount = 0;
    double totalClarityScore = 0.0;
    int validAnalysesCount = 0;

    for (var analysis in individualSpeechAnalyses) {
      if (analysis.containsKey('speakingRateWPM') &&
          analysis.containsKey('fillerWordCount') &&
          analysis.containsKey('clarityScore')) {
        totalSpeakingRateWPM += analysis['speakingRateWPM'] as double;
        totalFillerWordCount += analysis['fillerWordCount'] as int;
        totalClarityScore += analysis['clarityScore'] as double;
        validAnalysesCount++;
      }
    }

    final double overallSpeakingRateWPM = validAnalysesCount > 0
        ? totalSpeakingRateWPM / validAnalysesCount
        : 0.0;
    final double averageClarityScore = validAnalysesCount > 0
        ? totalClarityScore / validAnalysesCount
        : 0.0;

    // --- Aggregate Emotions ---
    Map<String, double> dominantEmotions = {};
    for (var emotionMap in emotionTimeline) {
      emotionMap.forEach((emotion, score) {
        dominantEmotions.update(emotion, (value) => value + score, ifAbsent: () => score);
      });
    }
    // Normalize or find the most dominant emotion if needed
    if (dominantEmotions.isNotEmpty) {
      final double totalEmotionScore = dominantEmotions.values.reduce((sum, score) => sum + score);
      dominantEmotions = dominantEmotions.map((key, value) => MapEntry(key, value / totalEmotionScore));
    }


    // --- Generate Overall Feedback (Placeholder for AI) ---
    // In a real application, this would be generated by an AI service
    // (e.g., FreeAiService) based on all the aggregated data.
    // For now, we'll create a simple summary.
    String overallFeedback = _generatePlaceholderOverallFeedback(
      overallSpeakingRateWPM,
      totalFillerWordCount,
      averageClarityScore,
      dominantEmotions,
      responses,
    );

    // --- Generate Suggestions for Improvement (Placeholder for AI) ---
    // Similar to overall feedback, this would ideally come from an AI.
    List<String> suggestionsForImprovement = _generatePlaceholderSuggestions(
      overallSpeakingRateWPM,
      totalFillerWordCount,
      averageClarityScore,
      responses,
    );

    debugPrint('Report generated: WPM=$overallSpeakingRateWPM, Fillers=$totalFillerWordCount, Clarity=$averageClarityScore');

    return InterviewAnalysis(
      overallSpeakingRateWPM: overallSpeakingRateWPM,
      totalFillerWordCount: totalFillerWordCount,
      averageClarityScore: averageClarityScore,
      dominantEmotions: dominantEmotions,
      overallFeedback: overallFeedback,
      suggestionsForImprovement: suggestionsForImprovement,
    );
  }

  // Placeholder for generating overall feedback.
  // In a real app, this would be an AI call.
  String _generatePlaceholderOverallFeedback(
      double wpm,
      int fillerCount,
      double clarity,
      Map<String, double> emotions,
      List<String> responses,
      ) {
    String feedback = 'Your interview performance was generally good. ';
    if (wpm < 100) {
      feedback += 'Consider increasing your speaking pace for better flow. ';
    } else if (wpm > 180) {
      feedback += 'Your speaking rate is quite fast; try to slow down slightly for clarity. ';
    }

    if (fillerCount > responses.length * 0.5) { // More than half the number of responses
      feedback += 'You used a noticeable number of filler words; practicing conciseness will help. ';
    }

    if (clarity < 0.7) {
      feedback += 'Focus on structuring your answers more clearly. ';
    }

    if (emotions.containsKey('nervous') && emotions['nervous']! > 0.5) {
      feedback += 'Some nervousness was detected; deep breaths can help. ';
    }

    return feedback.trim();
  }

  // Placeholder for generating suggestions.
  // In a real app, this would be an AI call.
  List<String> _generatePlaceholderSuggestions(
      double wpm,
      int fillerCount,
      double clarity,
      List<String> responses,
      ) {
    List<String> suggestions = [];

    if (wpm < 100) {
      suggestions.add('Practice speaking at a moderate pace (120-150 WPM).');
    } else if (wpm > 180) {
      suggestions.add('Consciously slow down your speech to ensure every word is clear.');
    }

    if (fillerCount > responses.length * 0.5) {
      suggestions.add('Record yourself and identify common filler words to reduce them.');
      suggestions.add('Pause briefly instead of using filler words.');
    }

    if (clarity < 0.7) {
      suggestions.add('Use the STAR method (Situation, Task, Action, Result) to structure behavioral answers.');
      suggestions.add('Practice explaining complex topics simply and concisely.');
    }

    if (suggestions.isEmpty) {
      suggestions.add('Keep practicing! Consistent effort leads to significant improvement.');
    }

    return suggestions;
  }
}

